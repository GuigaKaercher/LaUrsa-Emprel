{
  "version": 3,
  "sources": ["../../../../../@vitest/mocker/dist/chunk-registry.js", "../../../../../@vitest/mocker/dist/index.js"],
  "sourcesContent": ["class MockerRegistry {\r\n\tregistryByUrl = new Map();\r\n\tregistryById = new Map();\r\n\tclear() {\r\n\t\tthis.registryByUrl.clear();\r\n\t\tthis.registryById.clear();\r\n\t}\r\n\tkeys() {\r\n\t\treturn this.registryByUrl.keys();\r\n\t}\r\n\tadd(mock) {\r\n\t\tthis.registryByUrl.set(mock.url, mock);\r\n\t\tthis.registryById.set(mock.id, mock);\r\n\t}\r\n\tregister(typeOrEvent, raw, id, url, factoryOrRedirect) {\r\n\t\tconst type = typeof typeOrEvent === \"object\" ? typeOrEvent.type : typeOrEvent;\r\n\t\tif (typeof typeOrEvent === \"object\") {\r\n\t\t\tconst event = typeOrEvent;\r\n\t\t\tif (event instanceof AutomockedModule || event instanceof AutospiedModule || event instanceof ManualMockedModule || event instanceof RedirectedModule) {\r\n\t\t\t\tthrow new TypeError(`[vitest] Cannot register a mock that is already defined. ` + `Expected a JSON representation from \\`MockedModule.toJSON\\`, instead got \"${event.type}\". ` + `Use \"registry.add()\" to update a mock instead.`);\r\n\t\t\t}\r\n\t\t\tif (event.type === \"automock\") {\r\n\t\t\t\tconst module = AutomockedModule.fromJSON(event);\r\n\t\t\t\tthis.add(module);\r\n\t\t\t\treturn module;\r\n\t\t\t} else if (event.type === \"autospy\") {\r\n\t\t\t\tconst module = AutospiedModule.fromJSON(event);\r\n\t\t\t\tthis.add(module);\r\n\t\t\t\treturn module;\r\n\t\t\t} else if (event.type === \"redirect\") {\r\n\t\t\t\tconst module = RedirectedModule.fromJSON(event);\r\n\t\t\t\tthis.add(module);\r\n\t\t\t\treturn module;\r\n\t\t\t} else if (event.type === \"manual\") {\r\n\t\t\t\tthrow new Error(`Cannot set serialized manual mock. Define a factory function manually with \\`ManualMockedModule.fromJSON()\\`.`);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(`Unknown mock type: ${event.type}`);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (typeof raw !== \"string\") {\r\n\t\t\tthrow new TypeError(\"[vitest] Mocks require a raw string.\");\r\n\t\t}\r\n\t\tif (typeof url !== \"string\") {\r\n\t\t\tthrow new TypeError(\"[vitest] Mocks require a url string.\");\r\n\t\t}\r\n\t\tif (typeof id !== \"string\") {\r\n\t\t\tthrow new TypeError(\"[vitest] Mocks require an id string.\");\r\n\t\t}\r\n\t\tif (type === \"manual\") {\r\n\t\t\tif (typeof factoryOrRedirect !== \"function\") {\r\n\t\t\t\tthrow new TypeError(\"[vitest] Manual mocks require a factory function.\");\r\n\t\t\t}\r\n\t\t\tconst mock = new ManualMockedModule(raw, id, url, factoryOrRedirect);\r\n\t\t\tthis.add(mock);\r\n\t\t\treturn mock;\r\n\t\t} else if (type === \"automock\" || type === \"autospy\") {\r\n\t\t\tconst mock = type === \"automock\" ? new AutomockedModule(raw, id, url) : new AutospiedModule(raw, id, url);\r\n\t\t\tthis.add(mock);\r\n\t\t\treturn mock;\r\n\t\t} else if (type === \"redirect\") {\r\n\t\t\tif (typeof factoryOrRedirect !== \"string\") {\r\n\t\t\t\tthrow new TypeError(\"[vitest] Redirect mocks require a redirect string.\");\r\n\t\t\t}\r\n\t\t\tconst mock = new RedirectedModule(raw, id, url, factoryOrRedirect);\r\n\t\t\tthis.add(mock);\r\n\t\t\treturn mock;\r\n\t\t} else {\r\n\t\t\tthrow new Error(`[vitest] Unknown mock type: ${type}`);\r\n\t\t}\r\n\t}\r\n\tdelete(id) {\r\n\t\tthis.registryByUrl.delete(id);\r\n\t}\r\n\tget(id) {\r\n\t\treturn this.registryByUrl.get(id);\r\n\t}\r\n\tgetById(id) {\r\n\t\treturn this.registryById.get(id);\r\n\t}\r\n\thas(id) {\r\n\t\treturn this.registryByUrl.has(id);\r\n\t}\r\n}\r\nclass AutomockedModule {\r\n\ttype = \"automock\";\r\n\tconstructor(raw, id, url) {\r\n\t\tthis.raw = raw;\r\n\t\tthis.id = id;\r\n\t\tthis.url = url;\r\n\t}\r\n\tstatic fromJSON(data) {\r\n\t\treturn new AutospiedModule(data.raw, data.id, data.url);\r\n\t}\r\n\ttoJSON() {\r\n\t\treturn {\r\n\t\t\ttype: this.type,\r\n\t\t\turl: this.url,\r\n\t\t\traw: this.raw,\r\n\t\t\tid: this.id\r\n\t\t};\r\n\t}\r\n}\r\nclass AutospiedModule {\r\n\ttype = \"autospy\";\r\n\tconstructor(raw, id, url) {\r\n\t\tthis.raw = raw;\r\n\t\tthis.id = id;\r\n\t\tthis.url = url;\r\n\t}\r\n\tstatic fromJSON(data) {\r\n\t\treturn new AutospiedModule(data.raw, data.id, data.url);\r\n\t}\r\n\ttoJSON() {\r\n\t\treturn {\r\n\t\t\ttype: this.type,\r\n\t\t\turl: this.url,\r\n\t\t\tid: this.id,\r\n\t\t\traw: this.raw\r\n\t\t};\r\n\t}\r\n}\r\nclass RedirectedModule {\r\n\ttype = \"redirect\";\r\n\tconstructor(raw, id, url, redirect) {\r\n\t\tthis.raw = raw;\r\n\t\tthis.id = id;\r\n\t\tthis.url = url;\r\n\t\tthis.redirect = redirect;\r\n\t}\r\n\tstatic fromJSON(data) {\r\n\t\treturn new RedirectedModule(data.raw, data.id, data.url, data.redirect);\r\n\t}\r\n\ttoJSON() {\r\n\t\treturn {\r\n\t\t\ttype: this.type,\r\n\t\t\turl: this.url,\r\n\t\t\traw: this.raw,\r\n\t\t\tid: this.id,\r\n\t\t\tredirect: this.redirect\r\n\t\t};\r\n\t}\r\n}\r\nclass ManualMockedModule {\r\n\tcache;\r\n\ttype = \"manual\";\r\n\tconstructor(raw, id, url, factory) {\r\n\t\tthis.raw = raw;\r\n\t\tthis.id = id;\r\n\t\tthis.url = url;\r\n\t\tthis.factory = factory;\r\n\t}\r\n\tasync resolve() {\r\n\t\tif (this.cache) {\r\n\t\t\treturn this.cache;\r\n\t\t}\r\n\t\tlet exports;\r\n\t\ttry {\r\n\t\t\texports = await this.factory();\r\n\t\t} catch (err) {\r\n\t\t\tconst vitestError = new Error(\"[vitest] There was an error when mocking a module. \" + \"If you are using \\\"vi.mock\\\" factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. \" + \"Read more: https://vitest.dev/api/vi.html#vi-mock\");\r\n\t\t\tvitestError.cause = err;\r\n\t\t\tthrow vitestError;\r\n\t\t}\r\n\t\tif (exports === null || typeof exports !== \"object\" || Array.isArray(exports)) {\r\n\t\t\tthrow new TypeError(`[vitest] vi.mock(\"${this.raw}\", factory?: () => unknown) is not returning an object. Did you mean to return an object with a \"default\" key?`);\r\n\t\t}\r\n\t\treturn this.cache = exports;\r\n\t}\r\n\tstatic fromJSON(data, factory) {\r\n\t\treturn new ManualMockedModule(data.raw, data.id, data.url, factory);\r\n\t}\r\n\ttoJSON() {\r\n\t\treturn {\r\n\t\t\ttype: this.type,\r\n\t\t\turl: this.url,\r\n\t\t\tid: this.id,\r\n\t\t\traw: this.raw\r\n\t\t};\r\n\t}\r\n}\r\n\r\nexport { AutomockedModule as A, MockerRegistry as M, RedirectedModule as R, ManualMockedModule as a, AutospiedModule as b };\r\n", "export { A as AutomockedModule, b as AutospiedModule, a as ManualMockedModule, M as MockerRegistry, R as RedirectedModule } from './chunk-registry.js';\r\n\r\nfunction mockObject(options, object, mockExports = {}) {\r\n\tconst finalizers = new Array();\r\n\tconst refs = new RefTracker();\r\n\tconst define = (container, key, value) => {\r\n\t\ttry {\r\n\t\t\tcontainer[key] = value;\r\n\t\t\treturn true;\r\n\t\t} catch {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\tconst mockPropertiesOf = (container, newContainer) => {\r\n\t\tconst containerType = getType(container);\r\n\t\tconst isModule = containerType === \"Module\" || !!container.__esModule;\r\n\t\tfor (const { key: property, descriptor } of getAllMockableProperties(container, isModule, options.globalConstructors)) {\r\n\t\t\t// Modules define their exports as getters. We want to process those.\r\n\t\t\tif (!isModule && descriptor.get) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tObject.defineProperty(newContainer, property, descriptor);\r\n\t\t\t\t} catch {}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// Skip special read-only props, we don't want to mess with those.\r\n\t\t\tif (isSpecialProp(property, containerType)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst value = container[property];\r\n\t\t\t// Special handling of references we've seen before to prevent infinite\r\n\t\t\t// recursion in circular objects.\r\n\t\t\tconst refId = refs.getId(value);\r\n\t\t\tif (refId !== undefined) {\r\n\t\t\t\tfinalizers.push(() => define(newContainer, property, refs.getMockedValue(refId)));\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst type = getType(value);\r\n\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\tdefine(newContainer, property, []);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst isFunction = type.includes(\"Function\") && typeof value === \"function\";\r\n\t\t\tif ((!isFunction || value._isMockFunction) && type !== \"Object\" && type !== \"Module\") {\r\n\t\t\t\tdefine(newContainer, property, value);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// Sometimes this assignment fails for some unknown reason. If it does,\r\n\t\t\t// just move along.\r\n\t\t\tif (!define(newContainer, property, isFunction ? value : {})) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (isFunction) {\r\n\t\t\t\tif (!options.spyOn) {\r\n\t\t\t\t\tthrow new Error(\"[@vitest/mocker] `spyOn` is not defined. This is a Vitest error. Please open a new issue with reproduction.\");\r\n\t\t\t\t}\r\n\t\t\t\tconst spyOn = options.spyOn;\r\n\t\t\t\tfunction mockFunction() {\r\n\t\t\t\t\t// detect constructor call and mock each instance's methods\r\n\t\t\t\t\t// so that mock states between prototype/instances don't affect each other\r\n\t\t\t\t\t// (jest reference https://github.com/jestjs/jest/blob/2c3d2409879952157433de215ae0eee5188a4384/packages/jest-mock/src/index.ts#L678-L691)\r\n\t\t\t\t\tif (this instanceof newContainer[property]) {\r\n\t\t\t\t\t\tfor (const { key, descriptor } of getAllMockableProperties(this, false, options.globalConstructors)) {\r\n\t\t\t\t\t\t\t// skip getter since it's not mocked on prototype as well\r\n\t\t\t\t\t\t\tif (descriptor.get) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tconst value = this[key];\r\n\t\t\t\t\t\t\tconst type = getType(value);\r\n\t\t\t\t\t\t\tconst isFunction = type.includes(\"Function\") && typeof value === \"function\";\r\n\t\t\t\t\t\t\tif (isFunction) {\r\n\t\t\t\t\t\t\t\t// mock and delegate calls to original prototype method, which should be also mocked already\r\n\t\t\t\t\t\t\t\tconst original = this[key];\r\n\t\t\t\t\t\t\t\tconst mock = spyOn(this, key).mockImplementation(original);\r\n\t\t\t\t\t\t\t\tconst origMockReset = mock.mockReset;\r\n\t\t\t\t\t\t\t\tmock.mockRestore = mock.mockReset = () => {\r\n\t\t\t\t\t\t\t\t\torigMockReset.call(mock);\r\n\t\t\t\t\t\t\t\t\tmock.mockImplementation(original);\r\n\t\t\t\t\t\t\t\t\treturn mock;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconst mock = spyOn(newContainer, property);\r\n\t\t\t\tif (options.type === \"automock\") {\r\n\t\t\t\t\tmock.mockImplementation(mockFunction);\r\n\t\t\t\t\tconst origMockReset = mock.mockReset;\r\n\t\t\t\t\tmock.mockRestore = mock.mockReset = () => {\r\n\t\t\t\t\t\torigMockReset.call(mock);\r\n\t\t\t\t\t\tmock.mockImplementation(mockFunction);\r\n\t\t\t\t\t\treturn mock;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\t// tinyspy retains length, but jest doesn't.\r\n\t\t\t\tObject.defineProperty(newContainer[property], \"length\", { value: 0 });\r\n\t\t\t}\r\n\t\t\trefs.track(value, newContainer[property]);\r\n\t\t\tmockPropertiesOf(value, newContainer[property]);\r\n\t\t}\r\n\t};\r\n\tconst mockedObject = mockExports;\r\n\tmockPropertiesOf(object, mockedObject);\r\n\t// Plug together refs\r\n\tfor (const finalizer of finalizers) {\r\n\t\tfinalizer();\r\n\t}\r\n\treturn mockedObject;\r\n}\r\nclass RefTracker {\r\n\tidMap = new Map();\r\n\tmockedValueMap = new Map();\r\n\tgetId(value) {\r\n\t\treturn this.idMap.get(value);\r\n\t}\r\n\tgetMockedValue(id) {\r\n\t\treturn this.mockedValueMap.get(id);\r\n\t}\r\n\ttrack(originalValue, mockedValue) {\r\n\t\tconst newId = this.idMap.size;\r\n\t\tthis.idMap.set(originalValue, newId);\r\n\t\tthis.mockedValueMap.set(newId, mockedValue);\r\n\t\treturn newId;\r\n\t}\r\n}\r\nfunction getType(value) {\r\n\treturn Object.prototype.toString.apply(value).slice(8, -1);\r\n}\r\nfunction isSpecialProp(prop, parentType) {\r\n\treturn parentType.includes(\"Function\") && typeof prop === \"string\" && [\r\n\t\t\"arguments\",\r\n\t\t\"callee\",\r\n\t\t\"caller\",\r\n\t\t\"length\",\r\n\t\t\"name\"\r\n\t].includes(prop);\r\n}\r\nfunction getAllMockableProperties(obj, isModule, constructors) {\r\n\tconst { Map, Object, Function, RegExp, Array } = constructors;\r\n\tconst allProps = new Map();\r\n\tlet curr = obj;\r\n\tdo {\r\n\t\t// we don't need properties from these\r\n\t\tif (curr === Object.prototype || curr === Function.prototype || curr === RegExp.prototype) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tcollectOwnProperties(curr, (key) => {\r\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(curr, key);\r\n\t\t\tif (descriptor) {\r\n\t\t\t\tallProps.set(key, {\r\n\t\t\t\t\tkey,\r\n\t\t\t\t\tdescriptor\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t} while (curr = Object.getPrototypeOf(curr));\r\n\t// default is not specified in ownKeys, if module is interoped\r\n\tif (isModule && !allProps.has(\"default\") && \"default\" in obj) {\r\n\t\tconst descriptor = Object.getOwnPropertyDescriptor(obj, \"default\");\r\n\t\tif (descriptor) {\r\n\t\t\tallProps.set(\"default\", {\r\n\t\t\t\tkey: \"default\",\r\n\t\t\t\tdescriptor\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\treturn Array.from(allProps.values());\r\n}\r\nfunction collectOwnProperties(obj, collector) {\r\n\tconst collect = typeof collector === \"function\" ? collector : (key) => collector.add(key);\r\n\tObject.getOwnPropertyNames(obj).forEach(collect);\r\n\tObject.getOwnPropertySymbols(obj).forEach(collect);\r\n}\r\n\r\nexport { mockObject };\r\n"],
  "mappings": "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",
  "names": ["descriptor", "value", "type", "isFunction", "mock", "Map", "Object", "Array"]
}
